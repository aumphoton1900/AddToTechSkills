Files
1. public static Stream<String> lines​(Path path) throws IOException
Read all lines from a file as a Stream. Bytes from the file are decoded into characters using the UTF-8 charset.
Returns: the lines from the file as a Stream
Throws:
IOException - if an I/O error occurs opening the file
SecurityException - In the case of the default provider, and a security manager is installed, 
the checkRead method is invoked to check read access to the file.

1.2   public static Stream<String> lines(Path path) throws IOException
1.3   public static Stream<String> lines(Path path,Charset cs) throws IOException
      Read all lines from a file as a Stream.
https://www.logicbig.com/how-to/code-snippets/jcode-java-io-files-lines.html

class loader  - application ,Extension , 
bootstrap - serve as parent of 

Memory Management 
==================
https://javarush.com/en/groups/posts/en.917.garbage-collector-in-java
Permgen vs Metaspace 

Java 11 changes
-----------------
Removal of Java EE and CORBA Modules

In JDK 11, the Java EE and CORBA modules were removed. These modules were deprecated for removal in JDK 9.

The removed modules were:

java.xml.ws: Java API for XML Web Services (JAX-WS), Web Services Metadata for the Java Platform, and 
SOAP with Attachments for Java (SAAJ)
java.xml.bind: Java Architecture for XML Binding (JAXB)
java.xml.ws.annotation: The subset of the JSR-250 Common Annotations defined by Java SE to support web services
java.corba: CORBA
java.transaction: The subset of the Java Transaction API defined by Java SE to support CORBA Object Transaction Services
java.activation: JavaBeans Activation Framework
java.se.ee: Aggregator module for the six modules above
jdk.xml.ws: Tools for JAX-WS
jdk.xml.bind: Tools for JAXB

a) 
java.lang.ClassNotFoundException: javax.xml.ws.WebServiceFeature in Java 11.
Caused by: java.lang.ClassNotFoundException: javax.xml.ws.WebServiceFeature

https://crunchify.com/java-jdk-11-and-details-on-deprecated-java-ee-modules-including-jaxb-jax-ws-jaf-jta-corba/
https://www.studytonight.com/post/solved-caused-by-javalangclassnotfoundexception-javaxxmlwswebservicefeature-in-java-11

After java 11 changes.
dependency>
    <groupId>javax.xml.ws</groupId>
    <artifactId>jaxws-api</artifactId>
    <version>2.3.1</version>
</dependency>
This will include the jaxws-api Jar file in your project when you will build your maven java project.

https://www.baeldung.com/maven-goals-phases

Getting Ready for Java 11/JDK 11 and Deprecated Java EE Modules JAXB, JAX-WS, JAF, JTA, CORBA.
3.1
---
class Singleton implements Serializable {
 
    // public instance initialized when loading the class
    public static Singleton instance = new Singleton();
 
    private Singleton()
    {
        // private constructor
    }
 
    // implement readResolve method
    protected Object readResolve() { return instance; }
}
-----------
<<Java 17 changes >>
1.
switch statement was limited to 

byte, short, char, int, 
Byte, Character, Short, Integer, 
String, and Enum types.

to use patterns to match against the value of an object of any type.

Note: case statements can now be written as `case …expression ->’ instead of  ‘case expression:’ since Java 12.
Java 12 introduced an enhanced switch expression syntax that eliminates the need for break statements. 
This new syntax uses the -> operator instead of the traditional : 
for case labels. When a case matches, only the code to the right of the -> is executed, 
and there's no fall-through to the next case.

Furthermore, this also allows us to use multiple options as case labels. 
Here is an example of how to use the enhanced switch statement with multi-value labels:

int value = 5;
switch (value) {
    case 1 -> System.out.println("One");
    case 2 -> System.out.println("Two");
    case 3, 4 -> System.out.println("Three or Four");
    default -> System.out.println("Invalid value");
}
Below example shows the summary of types that are allowed in a case label till Java 21:

public String testType(Object obj) {  
    return switch (obj) { 
        case null -> "NULL value"; 
        case String str -> "It's a String";  
        case Size s -> "Enum Type"; 
        case Point p -> "Records Type"; 
        case Employee e -> "Custom Object's Type"; 
        case int[] ai -> "Array Type"; 
        case Employee e when e.getName().equals("John") -> "Conditional Statement";  
        default -> "Unknown"; 
     }; 
} 

public enum Size {  
   SMALL, MEDIUM, LARGE; 
} 
public record Point(int i, int j) { ..... } 
public class Employee{ ..... }
https://javatechonline.com/java-17-features/

In the example above, record is a new type introduced in Java 14. To know more about records type, 
kindly go through record type in Java 14 under Java 14 features.

The ‘when’ clause is added in Java 21 which allows us to include conditional statement in a case label.
This is called a guarded pattern label. 
For a separate comprehensive guide on Guarded Patterns with examples, kindly visit Guarded Pattern in Java 21.

2]
public class HelloWorld{

  public static String getDayOfWeek(int dayNum) {
    return switch (dayNum) {
        case 1 -> "Monday";
        case 2 -> "Tuesday";
        case 3 -> "Wednesday";
        case 4 -> "Thursday";
        case 5 -> "Friday";
        case 6 -> "Saturday";
        case 7 -> "Sunday";
        default -> "Invalid day";
    };
}

     public static void main(String []args){
        System.out.println(getDayOfWeek(3));
     }
} //wednesday

Note: case statements can now be written as `case …expression ->’ instead of  ‘case expression:’ since Java 12.
As shown in the example, since Java 12, the case statements now use the new arrow operator (->) to specify the pattern and 
the result expression. It also eliminates the break statement at each case.

record CreditCardPayment(String cardNumber) {}

//Record class for PayPalPayment
record PayPalPayment(String email) {}

public class PaymentProcessing {

    private static void processPayment(Object payment) {
        String result = switch (payment) {
            case CreditCardPayment cc ->
                 "Processing Credit Card payment with card number: " + cc.cardNumber();
            case PayPalPayment pp -> "Processing PayPal payment with email: " + pp.email();
            case Integer amount -> "Processing Cash payment of $" + amount;
            case null -> "Invalid payment method: null";
            default -> "Unknown payment method.";
        };
        System.out.println(result);
    }

    public static void main(String[] args) {
        processPayment(new CreditCardPayment("1234-5678-9876-5432"));
        processPayment(new PayPalPayment("user@example.com"));
        processPayment(500); 
        processPayment(null); 
    }
}

Switch Statements Since Java 17
In addition to using constant patterns, the new feature of java 17 also allows developers to use variable patterns 
and type patterns. A variable pattern allows you to match against a specific value and assign it to a variable. 
A type pattern allows you to match against the type of a value.

Here is an example that demonstrates the use of variable and type patterns:
This example demonstrates a simplified payment processing system that handles payments via credit card, PayPal, or cash. 
Here, case CreditCardPayment, and case PaypalPayment are type patterns, whereas case Integer is a variable pattern. 
Case null explicitly handles null values to identify invalid payment methods. Default case catches all unsupported payment methods.

2.b)
enhanced switch statement with multi-value labels:

Furthermore, this also allows us to use multiple options as case labels. 
Here is an example of how to use the enhanced switch statement with multi-value labels:

int value = 5;
switch (value) {
    case 1 -> System.out.println("One");
    case 2 -> System.out.println("Two");
    case 3, 4 -> System.out.println("Three or Four");
    default -> System.out.println("Invalid value");
}

2.c ) Pattern Matching for instanceof
Pattern Matching for instanceof
Java 17 introduces a short way of pattern matching for the instanceof operator, 
which helps to simplify the code required for type checks. With pattern matching, 
you can extract the value of the checked object into a new variable if the check succeeds. 
This new variable can then be used in following code. It eliminates the need to cast the object into the expected type.

Note that this was a preview feature introduced under Java 14 Features. It has become 
a permanent feature under the list of Java 17 features.

Here is an example of how pattern matching can simplify code that uses the instanceof operator:

// Old way with pattern matching (Before Java 17)

if (obj instanceof String) {
     String str = (String) obj;
     System.out.println(str.length());
}
// New way with pattern matching (Since Java 17)

if (obj instanceof String str) {
    System.out.println(str.length());
}

2.d)
Sealed Classes & Interfaces

Sealed classes and interfaces offer a restriction whether classes/interfaces can extend/implement other classes/interfaces or not.
In simple words, Sealed Classes work by specifying which classes or interfaces are allowed to extend or 
implement a particular class or interface. This is achieved by using the “sealed” modifier on the parent class or 
interface, and then specifying the allowed subclasses or implementing classes using the “permits” keyword.
Sealed Classes were proposed by JEP 360 and delivered in JDK 15 as a preview feature. 
They were proposed again, with some refinements, and delivered in JDK 16 as a preview feature. 
Now in JDK 17, Sealed Classes are being finalized with no changes from JDK 16.\

public sealed class Shape permits Circle, Square, Triangle {
    // ...
}
In the example, the “sealed” modifier is used to specify that the Shape class is a sealed class. 
The “permits” keyword is then used to specify the allowed subclasses of Shape, which are Circle, Square, and Triangle.

2.e)
Enhanced Pseudo-Random Number Generators
“Enhanced Pseudo-Random Number Generators” introduced under Java 17 Features. 

2.f)
Restore Always-Strict Floating-Point Semantics

2.g)
Strongly Encapsulate JDK Internals

The “Strongly Encapsulate JDK Internals” feature in Java 17 aims to further enhance 
the encapsulation of internal APIs in the JDK (Java Development Kit). 
The goal is to limit the use of internal APIs by third-party applications and libraries, 
which can improve the security and stability of Java applications.



==============================
>>> Memeory Leaks 

What Does a Memory Leak in JVM Mean?

A memory leak in the JVM (Java Virtual Machine) occurs when objects 
in the heap memory are no longer needed by the application but cannot be garbage 
collected because they are still being referenced. This leads to unnecessary retention of memory, 
which depletes system resources over time and can eventually cause the application to crash with an OutOfMemoryError.

Key Characteristics of a Memory Leak

Unused but Referenced Objects: These objects remain in memory because the garbage collector cannot 
identify them as unreferenced, even though they are no longer needed by the application.

Performance Degradation: Over time, memory leaks can lead to slower application performance and increased latency.

Application Crashes: If the memory usage exceeds the allocated heap size, the application may 
terminate with a fatal error.


Common Causes of Memory Leaks in JVM

Static Fields: Static variables persist for the lifetime of the application. 
If they hold references to large objects or collections, these objects cannot be garbage collected.

Unclosed Resources: Failing to close resources like database connections, input streams, or 
sockets can lead to memory leaks.

Improper equals() and hashCode() Implementations: Misconfigured methods can cause duplicate 
objects to accumulate in collections like HashMap or HashSet.

Inner Classes: Non-static inner classes hold implicit references to their enclosing classes, 
preventing garbage collection of the outer class.

ThreadLocals: Improper use of ThreadLocal variables can lead to memory leaks, especially 
in environments with thread pooling

=================================================
>> ThreadLocal 

Q1 : when to use ThreadLocal ?

Each thread gets a unique copy of the variable.
Ideal for storing state information like user sessions, transactions, or temporary data specific to a thread.
Eliminates the need for synchronisation when multiple threads access shared data.

Example-01 
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    
  // Define a ThreadLocal to hold data for each thread
    private static final ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -> 0);

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(10);

        // Submit 10 tasks to demonstrate ThreadLocal
        for (int i = 1; i <= 10; i++) {
            int threadId = i;
            executorService.submit(() -> {
                // Set a value in the ThreadLocal for the current thread
                threadLocal.set(threadId);
                System.out.println("Thread " + Thread.currentThread().getName() + " has set value: " + threadLocal.get());

                // Simulate some work
                try {
                    System.out.println("Thread: " + Thread.currentThread().getName() + " is sleeping");
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }

                // Retrieve and print the value from the ThreadLocal
                System.out.println("Thread " + Thread.currentThread().getName() + " still has value: " + threadLocal.get());

                threadLocal.remove();
            });
        }

        // Shutdown the executor service
        executorService.shutdown();
    }    
}

What is ThreadLocal?
ThreadLocal is a class in Java's java.lang package that provides thread-local variables. 
Each thread accessing such a variable 
has its own independent copy, meaning changes made by one thread are not visible to other threads.

===========================


