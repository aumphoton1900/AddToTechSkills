1.
https://vladmihalcea.com/optimistic-locking-version-property-jpa-hibernate/
However, this session-based database interaction is no longer the norm, especially when accessing services over the Internet. 
This is because you can no longer hold onto a database connection across multiple HTTP requests. 
For this reason, the ACID guarantees no longer hold when your application-level transaction spans over 
multiple HTTP requests as well as physical database transactions.
One example of an anomaly that can happen because reads and writes happen in different database transactions is the lost update phenomenon.

https://www.logicbig.com/tutorials/spring-framework/spring-data/pessimistic-locking-and-lock-annotation.html
https://stackoverflow.com/questions/4509086/what-is-the-difference-between-persist-and-merge-in-jpa-and-hibernate

https://medium.com/@rajibrath20/the-best-way-to-map-a-onetomany-relationship-with-jpa-and-hibernate-dbbf6dba00d3#:~:text=The%20inverse%20side%20of%20a%20bidirectional%20relationship%20must,entity%20that%20is%20the%20owner%20of%20the%20relationship.

2. why hibernate/jdbc can not use for global transaction mgmt but only for local transaction management.
3. cache 
https://medium.com/@himani.prasad016/caching-in-hibernate-3ad4f479fcc0
1st - session 
2nd - sessionFactory | CacheConcurrencyStrategy.
The cache concurrency strategy determines how multiple threads access the cache. 
Hibernate supports multiple cache concurrency strategies such as 
READ_ONLY, 
NONSTRICT_READ_WRITE, 
READ_WRITE, and 
TRANSACTIONAL.

hibernate cache , invalidate 
------------------------------------
To ensure data consistency, Hibernate provides a cache synchronization mechanism that 
automatically updates the cache when the database is updated. This mechanism is called cache invalidation. 
When an entity is updated, Hibernate invalidates the corresponding cache entry,
and the next time the entity is accessed, it is fetched from the database and stored in the cache.

>>To enable query caching in Hibernate, you need to set the hibernate.cache.use_query_cache property to true.
   spring.jpa.properties.hibernate.cache.use_query_cache=true
   spring.jpa.properties.hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory.
@Repository
public interface AuthorRepository extends CrudRepository<Author, Integer> {
    @QueryHints({ @QueryHint(name = "org.hibernate.cacheable", value ="true") })
    Author findByName(String name);
}
https://www.baeldung.com/spring-data-jpa-query-hints
https://medium.com/@javatechie/spring-data-jpa-query-hints-for-better-performance-1144b089ba03
----------------------------------------------------------------
4. embedded vs embeddedId ?

Typically, embeddable classes share the same table as the Entity 
in which they are embedded.If the id field exists 
in embeddable class (class annotated with @Embeddable) then 
to embed the embeddable class inside entity class, 
instead of @Embedded we have to use @EmbeddedId annotation.

------------------------------------------------------------------
5. how to save entity to db in hibernate
The Session interface has several methods that eventually result in saving data to the database: 
persist, save, update, merge, and saveOrUpdate. To understand the difference between these methods, 
we must first discuss the purpose of the Session as a persistence context, 
and the difference between the states of entity instances in relation to the Session.

. We can think of persistence context as a container or first-level cache for all the objects 
that we loaded or saved to a database during a session.

In Hibernate, the persistence context is represented by the org.hibernate.Session instance. 
For JPA, it’s the jakarta.persistence.EntityManager. 

2.2. States of Entity Instances
Any entity instance in our application appears in one of the three main states in relation to the Session persistence 
context:

transient — This instance isn’t, and never was, attached to a Session. This instance has no corresponding 
    rows in the database; it’s usually just a new object that we created to save to the database.
persistent — This instance is associated with a unique Session object. Upon flushing the Session to the database, 
   this entity is guaranteed to have a corresponding consistent record in the database.
detached — This instance was once attached to a Session (in a persistent state), but now it’s not. 
     An instance enters this state if we evict it from the context, clear or close the Session, 
    or put the instance through serialization/deserialization process.
Here’s a simplified state diagram with comments on Session methods that make the state transitions happen:
=======================================================
https://medium.com/@das.cse.kuet/optimistic-vs-pessimistic-locking-in-java-choosing-the-
right-approach-for-your-application-cd6279409303

LOCK : pessimistic vs optimistic 

Product product = entityManager.find(Product.class, productId, LockModeType.PESSIMISTIC_WRITE);
In this example, the system locks the product row in the database when a user selects an item to purchase. 
Other users who try to purchase 
the same product will either have to wait until the lock is released or receive an error.

Session I : important methods 
-------------------------------
void	evict(java.lang.Object object)
Remove this instance from the session cache.
void	flush()

Force this session to flush.

<T> T	get(java.lang.Class<T> entityType, java.io.Serializable id)
Return the persistent instance of the given entity class with the given identifier, 
      or null if there is no such persistent instance.

<T> T	get(java.lang.Class<T> entityType, java.io.Serializable id, LockMode lockMode)
Return the persistent instance of the given entity class with the given identifier, or 
       null if there is no such persistent instance.

<T> T	get(java.lang.Class<T> entityType, java.io.Serializable id, LockOptions lockOptions)
Return the persistent instance of the given entity class with the given identifier, or  
      null if there is no such persistent instance.

java.lang.Object	get(java.lang.String entityName, java.io.Serializable id)
Return the persistent instance of the given named entity with the given identifier, or 
         null if there is no such persistent instance.

java.lang.Object	get(java.lang.String entityName, java.io.Serializable id, LockMode lockMode)
Return the persistent instance of the given entity class with the given identifier, or 
            null if there is no such persistent instance.

java.lang.Object	get(java.lang.String entityName, java.io.Serializable id, LockOptions lockOptions)
Return the persistent instance of the given entity class with the given identifier, or 
   null if there is no such persistent instance.
----------------------------

