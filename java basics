1] default constructor 

 In Java, a default constructor is automatically provided by the compiler only 
   if no constructors are explicitly defined in the class. Here's how it works:

When is it generated?

If you do not define any constructor in your class, the Java compiler automatically generates 
   a default constructor during compilation.
This default constructor is a no-argument constructor and initializes the object with default values 
   (e.g., 0 for numeric types, false for boolean, and null for objects).
When is it NOT generated?

If you define any constructor (e.g., a parameterized constructor), 
   the compiler does not generate a default constructor. In such cases, 
   you must explicitly define a no-argument constructor if needed.

   Example:
Copy code
// Case 1: No constructor defined
class Example1 {
    // Compiler automatically generates:
    // Example1() { }
}

// Case 2: Parameterized constructor defined
class Example2 {
    Example2(String name) {
        System.out.println("Hello, " + name);
    }
    // No default constructor is generated here!
}

public class Main {
    public static void main(String[] args) {
        Example1 obj1 = new Example1(); // Works fine
        // Example2 obj2 = new Example2(); // Compilation error: no default constructor
    }
}
Key Notes:

The default constructor is implicit and only exists if no other constructors are defined.
If you need both a parameterized and a no-argument constructor, you must explicitly define the no-argument constructor.
This behavior ensures that Java maintains flexibility while allowing developers to control object initialization. 

2] 
overloading 

Overloading does not depend on the return type of the method, 
two methods cannot be overloaded by just changing the return type.

In Java, when you pass null to an overloaded method, 
the compiler determines which method to call based on the most specific type. 
If you have overloaded methods that accept String and Object, and 
you pass null, the method with the String parameter will be chosen because String is more specific than Object.

Hereâ€™s an example:


Copy code
public class Test {
    public void method(String str) {
        System.out.println("String method called");
    }

    public void method(Object obj) {
        System.out.println("Object method called");
    }

    public static void main(String[] args) {
        Test test = new Test();
        test.method(null); // Calls the String method
    }
}
Explanation:
The compiler chooses the most specific method (String in this case) because String is a subclass of Object.
If there are multiple overloaded methods with equally specific types (e.g., String and Integer), 
the compiler will throw an ambiguity error.

Forcing Object Method:
If you want to explicitly call the Object method, you can cast null to Object:

Copy code
test.method((Object) null); // Calls the Object method
This ensures that the compiler treats null as an Object reference rather than a String.

https://stackoverflow.com/questions/15046763/passing-null-to-the-method-preferring-string-not-object
https://javalaunchpad.com/method-overloading-in-java-essential-oca-java-8-tips-tricks/
========================
