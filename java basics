1] default constructor 

 In Java, a default constructor is automatically provided by the compiler only 
   if no constructors are explicitly defined in the class. Here's how it works:

When is it generated?

If you do not define any constructor in your class, the Java compiler automatically generates 
   a default constructor during compilation.
This default constructor is a no-argument constructor and initializes the object with default values 
   (e.g., 0 for numeric types, false for boolean, and null for objects).
When is it NOT generated?

If you define any constructor (e.g., a parameterized constructor), 
   the compiler does not generate a default constructor. In such cases, 
   you must explicitly define a no-argument constructor if needed.

   Example:
Copy code
// Case 1: No constructor defined
class Example1 {
    // Compiler automatically generates:
    // Example1() { }
}

// Case 2: Parameterized constructor defined
class Example2 {
    Example2(String name) {
        System.out.println("Hello, " + name);
    }
    // No default constructor is generated here!
}

public class Main {
    public static void main(String[] args) {
        Example1 obj1 = new Example1(); // Works fine
        // Example2 obj2 = new Example2(); // Compilation error: no default constructor
    }
}
Key Notes:

The default constructor is implicit and only exists if no other constructors are defined.
If you need both a parameterized and a no-argument constructor, you must explicitly define the no-argument constructor.
This behavior ensures that Java maintains flexibility while allowing developers to control object initialization. 

2] 
overloading 

Overloading does not depend on the return type of the method, 
two methods cannot be overloaded by just changing the return type.

In Java, when you pass null to an overloaded method, 
the compiler determines which method to call based on the most specific type. 
If you have overloaded methods that accept String and Object, and 
you pass null, the method with the String parameter will be chosen because String is more specific than Object.

Hereâ€™s an example:

2.01 
Copy code
public class Test {
    public void method(String str) {
        System.out.println("String method called");
    }

    public void method(Object obj) {
        System.out.println("Object method called");
    }

    public static void main(String[] args) {
        Test test = new Test();
        test.method(null); // Calls the String method
    }
}
Explanation:
The compiler chooses the most specific method (String in this case) because String is a subclass of Object.
If there are multiple overloaded methods with equally specific types (e.g., String and Integer), 
the compiler will throw an ambiguity error.

Forcing Object Method:
If you want to explicitly call the Object method, you can cast null to Object:

Copy code
test.method((Object) null); // Calls the Object method
This ensures that the compiler treats null as an Object reference rather than a String.

https://stackoverflow.com/questions/15046763/passing-null-to-the-method-preferring-string-not-object
https://javalaunchpad.com/method-overloading-in-java-essential-oca-java-8-tips-tricks/
========================
Long Example :: autoboxing 

(2.02)
class MathUtils {

    //public static int add(int a, int b) {
    //    System.out.println("int version being called");
    //    return a + b;
     //}
    
     public static long add(long a, long b) {
        System.out.println("long version being called");
        return a + b;
    }
    
    public static int add(Integer a, Integer b) {
        System.out.println("Integer version being called");
        return a + b;
    }
}

class Main {
    public static void main(String[] args) {
        System.out.println(MathUtils.add(3, 5));
    }
}
long version being called
8
------------------
3. widening conversion 

Widening primitive conversion in Java 
refers to the automatic conversion of a smaller 
primitive type to a larger one, ensuring no loss of information

3.b) 
narrow example

class Demo {
    
    public void show(int x)
    {
        System.out.println("In int" + x);
    }
    public void show(String s)
    {
        System.out.println("In String" + s);
    }
    public void show(byte b)
    {
        System.out.println("In byte" + b);
    }
}

public class UseDemo {
    
    public static void main(String[] args)
    {
        byte a = 25;
        Demo obj = new Demo();

        // it will go to
        // byte argument
        obj.show(a);

        // String
        obj.show("hello");

        // Int
        obj.show(250);

        // Since char is
        // not available, so the datatype
        // higher than char in terms of
        // range is int.
        obj.show('A');

        // String
        obj.show("A");

        // since float datatype
        // is not available and so it's higher
        // datatype, so at this step their
        // will be an error.
        obj.show(7.5);
    }
}
 obj.show(7.5);
           ^
    method Demo.show(int) is not applicable
      (argument mismatch; possible lossy conversion from double to int)
    method Demo.show(String) is not applicable
      (argument mismatch; double cannot be converted to String)
    method Demo.show(byte) is not applicable
      (argument mismatch; possible lossy conversion from double to byte)
1 error
error: compilation failed
https://www.geeksforgeeks.org/java/method-overloading-in-java/
--------------------------------------------

4) Key Points of Method Overriding
Same Method Signature: The method in the subclass must have the same name, return type, 
and parameters as the method in the superclass.
Access Modifier: The overriding method cannot have a more restrictive access modifier 
than the method in the superclass (e.g., a protected method in the superclass cannot be 
overridden as private in the subclass).

Annotations: The @Override annotation is optional but recommended to ensure the method 
is correctly overriding a superclass method.
Runtime Polymorphism: Method overriding is resolved at runtime, enabling dynamic method dispatch.
Example Code

Copy code
// Superclass
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

// Subclass
class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

// Main Class
public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal(); // Superclass reference
        myAnimal.sound(); // Output: Animal makes a sound

        Animal myDog = new Dog(); // Polymorphism
        myDog.sound(); // Output: Dog barks
    }
}
Explanation
The sound() method in the Dog class overrides the sound() method in the Animal class.
When the myDog object is created with a reference of type Animal, 
the overridden method in the Dog class is called due to runtime polymorphism.
This demonstrates how method overriding allows subclasses to provide 
specific behavior while maintaining a consistent interface.
--------------------------------------------------------------------
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

// Subclass
class Dog extends Animal {
   // @Override
    //void sound() {
    //    super.sound();
    //    System.out.println("Dog barks");
    //}
}

// Main Class
public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal(); // Superclass reference
        myAnimal.sound(); // Output: Animal makes a sound

        Animal myDog = new Dog(); // Polymorphism
        myDog.sound(); // Output: Dog barks
    }
}
Animal makes a sound
Animal makes a sound
---------------------------------

