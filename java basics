1] default constructor 

 In Java, a default constructor is automatically provided by the compiler only 
   if no constructors are explicitly defined in the class. Here's how it works:

When is it generated?

If you do not define any constructor in your class, the Java compiler automatically generates 
   a default constructor during compilation.
This default constructor is a no-argument constructor and initializes the object with default values 
   (e.g., 0 for numeric types, false for boolean, and null for objects).
When is it NOT generated?

If you define any constructor (e.g., a parameterized constructor), 
   the compiler does not generate a default constructor. In such cases, 
   you must explicitly define a no-argument constructor if needed.

   Example:
Copy code
// Case 1: No constructor defined
class Example1 {
    // Compiler automatically generates:
    // Example1() { }
}

// Case 2: Parameterized constructor defined
class Example2 {
    Example2(String name) {
        System.out.println("Hello, " + name);
    }
    // No default constructor is generated here!
}

public class Main {
    public static void main(String[] args) {
        Example1 obj1 = new Example1(); // Works fine
        // Example2 obj2 = new Example2(); // Compilation error: no default constructor
    }
}
Key Notes:

The default constructor is implicit and only exists if no other constructors are defined.
If you need both a parameterized and a no-argument constructor, you must explicitly define the no-argument constructor.
This behavior ensures that Java maintains flexibility while allowing developers to control object initialization. 

2] 
overloading 

Overloading does not depend on the return type of the method, 
two methods cannot be overloaded by just changing the return type.

In Java, when you pass null to an overloaded method, 
the compiler determines which method to call based on the most specific type. 
If you have overloaded methods that accept String and Object, and 
you pass null, the method with the String parameter will be chosen because String is more specific than Object.

Here’s an example:

2.01 
Copy code
public class Test {
    public void method(String str) {
        System.out.println("String method called");
    }

    public void method(Object obj) {
        System.out.println("Object method called");
    }

    public static void main(String[] args) {
        Test test = new Test();
        test.method(null); // Calls the String method
    }
}
Explanation:
The compiler chooses the most specific method (String in this case) because String is a subclass of Object.
If there are multiple overloaded methods with equally specific types (e.g., String and Integer), 
the compiler will throw an ambiguity error.

Forcing Object Method:
If you want to explicitly call the Object method, you can cast null to Object:

Copy code
test.method((Object) null); // Calls the Object method
This ensures that the compiler treats null as an Object reference rather than a String.

https://stackoverflow.com/questions/15046763/passing-null-to-the-method-preferring-string-not-object
https://javalaunchpad.com/method-overloading-in-java-essential-oca-java-8-tips-tricks/
========================
Long Example :: autoboxing 

(2.02)
class MathUtils {

    //public static int add(int a, int b) {
    //    System.out.println("int version being called");
    //    return a + b;
     //}
    
     public static long add(long a, long b) {
        System.out.println("long version being called");
        return a + b;
    }
    
    public static int add(Integer a, Integer b) {
        System.out.println("Integer version being called");
        return a + b;
    }
}

class Main {
    public static void main(String[] args) {
        System.out.println(MathUtils.add(3, 5));
    }
}
long version being called
8
------------------
3. widening conversion 

Widening primitive conversion in Java 
refers to the automatic conversion of a smaller 
primitive type to a larger one, ensuring no loss of information

3.b) 
narrow example

class Demo {
    
    public void show(int x)
    {
        System.out.println("In int" + x);
    }
    public void show(String s)
    {
        System.out.println("In String" + s);
    }
    public void show(byte b)
    {
        System.out.println("In byte" + b);
    }
}

public class UseDemo {
    
    public static void main(String[] args)
    {
        byte a = 25;
        Demo obj = new Demo();

        // it will go to
        // byte argument
        obj.show(a);

        // String
        obj.show("hello");

        // Int
        obj.show(250);

        // Since char is
        // not available, so the datatype
        // higher than char in terms of
        // range is int.
        obj.show('A');

        // String
        obj.show("A");

        // since float datatype
        // is not available and so it's higher
        // datatype, so at this step their
        // will be an error.
        obj.show(7.5);
    }
}
 obj.show(7.5);
           ^
    method Demo.show(int) is not applicable
      (argument mismatch; possible lossy conversion from double to int)
    method Demo.show(String) is not applicable
      (argument mismatch; double cannot be converted to String)
    method Demo.show(byte) is not applicable
      (argument mismatch; possible lossy conversion from double to byte)
1 error
error: compilation failed
https://www.geeksforgeeks.org/java/method-overloading-in-java/
--------------------------------------------

4) Key Points of Method Overriding
Same Method Signature: The method in the subclass must have the same name, return type, 
and parameters as the method in the superclass.
Access Modifier: The overriding method cannot have a more restrictive access modifier 
than the method in the superclass (e.g., a protected method in the superclass cannot be 
overridden as private in the subclass).

Annotations: The @Override annotation is optional but recommended to ensure the method 
is correctly overriding a superclass method.
Runtime Polymorphism: Method overriding is resolved at runtime, enabling dynamic method dispatch.
Example Code

Copy code
// Superclass
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

// Subclass
class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

// Main Class
public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal(); // Superclass reference
        myAnimal.sound(); // Output: Animal makes a sound

        Animal myDog = new Dog(); // Polymorphism
        myDog.sound(); // Output: Dog barks
    }
}
Explanation
The sound() method in the Dog class overrides the sound() method in the Animal class.
When the myDog object is created with a reference of type Animal, 
the overridden method in the Dog class is called due to runtime polymorphism.
This demonstrates how method overriding allows subclasses to provide 
specific behavior while maintaining a consistent interface.
--------------------------------------------------------------------
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

// Subclass
class Dog extends Animal {
   // @Override
    //void sound() {
    //    super.sound();
    //    System.out.println("Dog barks");
    //}
}

// Main Class
public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal(); // Superclass reference
        myAnimal.sound(); // Output: Animal makes a sound

        Animal myDog = new Dog(); // Polymorphism
        myDog.sound(); // Output: Dog barks
    }
}
Animal makes a sound
Animal makes a sound

Explanation
The sound() method in the Dog class overrides the sound() method in the Animal class.
When the myDog object is created with a reference of type Animal, 
the overridden method in the Dog class is called due to runtime polymorphism.
---------------------------------
2. Type Promotion (Widening)

When there’s no exact match, Java tries to promote the type to the next wider type in its type hierarchy, 
following this order:
— byte → short → int → long → float → double
— char → int
-------------------------------
3. overriding staic method 

Why Static Methods Cannot Be Overridden in Java

In Java, static methods cannot be overridden because they are associated with the class 
rather than any specific instance. Overriding relies on dynamic method dispatch, which 
is based on runtime polymorphism and works with instance methods. Static methods, however, 
are resolved at compile time, not runtime.

If you attempt to "override" a static method in a subclass, it results in method hiding, 
not true overriding. Here's an explanation of the behavior:

Key Points
Static Methods Belong to the Class: Static methods are tied to the class, 
not an object. Overriding requires an instance of the class, which static methods do not depend on.
Compile-Time Resolution: Static methods are resolved during compilation, 
whereas overridden methods are resolved at runtime.
Method Hiding: If a subclass defines a static method with the same signature 
as a static method in the parent class, the subclass method hides the parent class method. This is not overriding.

Example of Method Hiding

Copy code
class Parent {
    static void display() {
        System.out.println("Static method in Parent class");
    }
}

class Child extends Parent {
    static void display() {
        System.out.println("Static method in Child class");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent obj1 = new Parent();
        Parent obj2 = new Child();

        obj1.display(); // Output: Static method in Parent class
        obj2.display(); // Output: Static method in Parent class
    }
}
Explanation of the Output
obj1.display() calls the Parent class's static method because display() is resolved at compile time.
obj2.display() also calls the Parent class's static method, even though obj2 is a reference to a Child object. 
This is because static methods are not polymorphic and are resolved based on the reference type, not the object type.

Error Scenarios
If you try to override a static method and expect runtime polymorphism, it will not work as intended. However, 
the code will not throw a compile-time error because Java allows method hiding.
If you need polymorphic behavior, consider using instance methods instead of static methods.
================================
