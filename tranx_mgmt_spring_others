1. https://www.youtube.com/watch?v=qUsh8ukxnlw&list=PLD245PhfkYpjbHZqpTNWjvL5eTgveqXSP
before apprival of spring bean. 
- work with jdbc/hibernate for local transaction management in programatic approach.
- work with jta for global transaction management in programatic approach. 
- work with ejb for global transaction managment for declarative approach. (xml)
- hibernate code for local transaction management - java code (programatic) 

- why you can not use jdbc/hiberante for global transaction management ? 

For example, code that manages transactions using a JDBC connection cannot run within 
a global JTA transaction. Because the application server is not involved in transaction management, 
it cannot help ensure correctness across multiple resources.

Hibernate, while excellent for managing local transactions, typically relies on a database's 
built-in transaction management. 
It cannot directly handle global transactions that span multiple databases or resources, 
which require a more robust transaction manager like JTA (Java Transaction API). 

Elaboration:
1. Hibernate's Focus:
Hibernate focuses on managing transactions within a single database connection (local transactions). 
It uses the database's internal mechanisms to handle these transactions, such as BEGIN TRANSACTION, COMMIT, and ROLLBACK. 

2. Global Transactions Need JTA:
Global transactions, which involve multiple databases or resources, require a transaction manager that 
can coordinate the transactions across all participating resources. This is typically handled by 
JTA (Java Transaction API), which provides a standard way for applications to manage distributed transactions. 

3. Hibernate's API Limitations:
While Hibernate provides transaction management APIs, they are designed for managing local transactions 
within a single database context. They don't offer the functionality needed to manage the 
complexities of global transactions, especially when dealing with multiple databases. 

4. Application Server Involvement:
In environments where global transactions are needed (e.g., enterprise applications with multiple databases), 
application servers (like JBoss) typically provide JTA implementations that handle global transaction management. 

5. Example: Spring Framework:
Frameworks like Spring can integrate with Hibernate and provide features for managing transactions, 
including declarative transaction management via annotations like @Transactional. 
However, Spring itself doesn't implement a global transaction manager. 
It relies on the application server's JTA implementation for managing global transactions. 

6. In summary:
Hibernate's transaction management capabilities are well-suited for local transactions within a single database. 
For global transactions, you'll need a dedicated transaction manager (like JTA) and potentially 
the assistance of an application server. 




2.]
Hibernate
Hibernate provides its own org.hibernate.Transaction interface to manage transactions. 
You obtain a transaction using session.beginTransaction(). 
Similar to JDBC, you use transaction.commit() to persist changes or transaction.rollback() to discard changes.

Session session = sessionFactory.openSession();
Transaction transaction = null;
try {
    transaction = session.beginTransaction();
    // Perform database operations
    transaction.commit();
} catch (Exception e) {
    if (transaction != null) transaction.rollback();
} finally {
    session.close();
}



JDBC
In JDBC, local transaction management is achieved by using the java.sql.Connection interface. 
By default, each SQL statement is executed within its own transaction (auto-commit mode). 
To manage transactions explicitly, you need to disable auto-commit mode using connection.setAutoCommit(false).
After disabling auto-commit, you can use connection.commit() to persist changes or 
connection.rollback() to discard changes in case of errors.

Connection connection = dataSource.getConnection();
try {
    connection.setAutoCommit(false);
    // Perform database operations
    connection.commit();
} catch (SQLException e) {
    connection.rollback();
} finally {
    connection.setAutoCommit(true);
    connection.close();
}
one connection for one connection db . 
two connection for two db. 
if conn2.commit() throws exception , conn1.commit() can not be rollback . [ sql , oracle]
if conn2.rollback() throws exception , conn1.rollback() execution gives problem .
same issue in case of hibernate , so both are not good for global transaction management. 


===================================================
- weblogic application server 

======================================
For Global transaction management , 
you need global transaction manager / distributed tx manager , who 
perform commit and rollback operations on the multiple DBs  of same boundry ( belong to same tx) in single short. 
 => generally you get distributed txmgr from application server logic (weblogic / glassfish and etc)... or from third pary 
or from third party vendors like atomokis , narayana. 

===================
Oracle Web Logic Server 
 javax - > 1. jms   ;  
           2. transaction - transactionManager , transactionSyncronizationRegistry , 
                            UserTransaction ( this is distributed transaction manager)
in application server the distributed TxManager is placed in jndi registry , having fixed jndi name 
in case weblogic server , the jndi name - javax.transaction.UserTransaction 
=========================
Distributed TxMgt using jta in programatic approach 
public <RT> b.method(<params>) {
  // get distributed Tx Mgmr from the jndi registry underlying server 
  InitialContext ic = new InitialContext();
UserTransaction ut = ic.lookup("javax/transaction/UserTransaction"); 
// from server or some third party need to look up operation to get distributed transaction manager. 
// begin distributed Tx 
  ut.begin();
...// what ever connection/session you create here you shall create using xa drivers. 
// then only this 2pc protocl works nicely.
.. // sql quesries to execute on multiple Dbs using multiple connections / sessions
 // let say talk to 3 db , it will keep track of talk to 3 db within a boundry
ut.commit() //data  modified in 10 dbs s/w ( 10 db data) will commit in single shot
 // who will take care distributed transaction manager will take care. by using 2 pc protocol. 
// if all perfectly modified 
}
catch(Exception ex) {
ut.rollback(); // all 10 db data will rollback in single shot.
}
// this code gainst aop.
do not use normal drivers , use xa drivers 
-- services - datasources - new - generic data source - Data base drivers - xa databases drivers. 
- after calling ut.begin() , if the code performing persistence operation on 3 dbs then will go 
  tx boundry and 2pc protocol will be implemented on them.
============================




        

