1]
public class CopyOnWriteArrayList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
    private static final long serialVersionUID = 8673264195747942595L;
    /** The lock protecting all mutators */
    final transient ReentrantLock lock = new ReentrantLock();
    /** The array, accessed only via getArray/setArray. */
    private transient volatile Object[] array;

 public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
--------------------
2]
3. Donâ€™t want to use synchronized ArrayList
As you know we can make a thread safe ArrayList by use synchronization. 
But synchronized ArrayList has some  limitation. 

In synchronized list all the read and write methods are synchronized. It means if a thread performs write operation, 
it blocks other threads even they just want to perform only read operations.
Reason: CopyOnWriteArrayList provide some more flexibility than synchronization.

1. In CopyOnWriteArrayList multiple threads can perform read operations concurrently.
2. If one thread performing read operation meanwhile another thread can write operation concurrently.
3. One thread can perform write operation while other threads can execute read operations simultaneously.

https://javagoal.com/java-copyonwritearrayset/
--------------------------------------------
ArrayList vs LinkedList 

In Java, ArrayList and LinkedList are two implementations of the List interface, each with distinct characteristics and use cases. Here's a concise comparison:

1. Underlying Data Structure
ArrayList: Uses a dynamic array to store elements.
LinkedList: Uses a doubly-linked list, where each node contains data and references to the next and previous nodes.
2. Performance
Access (Get/Set):
ArrayList: Faster, as it provides O(1) time complexity for random access.
LinkedList: Slower, as it requires O(n) time complexity to traverse nodes.
Insertion/Deletion:
ArrayList: Slower for operations in the middle or beginning, as it involves shifting elements (O(n)).
LinkedList: Faster for insertion/deletion at the middle or beginning (O(1) if the node reference is known).
Memory Usage:
ArrayList: More memory-efficient as it only stores data.
LinkedList: Consumes more memory due to node pointers (next and previous
---------------------------------------------

