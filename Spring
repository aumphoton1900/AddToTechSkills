Transaction Management
1.
Mixing the database I/O with other types of I/O in a transactional context isn’t a great idea.
So, the first solution for these sorts of problems is to separate these types of I/O altogether.
If for whatever reason we can’t separate them, we can still use Spring APIs to manage transactions manually.

Using TransactionTemplate
TransactionTemplate provides a set of callback-based APIs to manage transactions manually. 
In order to use it, we should first initialize it with a PlatformTransactionManager.
// test annotations
class ManualTransactionIntegrationTest {
    @Autowired
    private PlatformTransactionManager transactionManager;
    private TransactionTemplate transactionTemplate;
    @BeforeEach
    void setUp() {
        transactionTemplate = new TransactionTemplate(transactionManager);
    } 
    // omitted
}
The PlatformTransactionManager helps the template to create, commit or roll back transactions.
When using Spring Boot, an appropriate bean of type PlatformTransactionManager will be automatically registered,
so we just need to simply inject it. 
Otherwise, we should manually register a PlatformTransactionManager bean.

1) Class DefaultTransactionDefinition
All Implemented Interfaces:
Serializable, TransactionDefinition
Direct Known Subclasses:
DefaultTransactionAttribute, TransactionTemplate

PREFIX_ISOLATION  Prefix for the isolation constants defined in TransactionDefinition.
PREFIX_PROPAGATION Prefix for the propagation constants defined in TransactionDefinition.
PREFIX_TIMEOUT Prefix for transaction timeout values in description strings.
READ_ONLY_MARKER Marker for read-only transactions in description strings.

Fields inherited from interface org.springframework.transaction.TransactionDefinition
ISOLATION_DEFAULT, ISOLATION_READ_COMMITTED, 
ISOLATION_READ_UNCOMMITTED, ISOLATION_REPEATABLE_READ, 
ISOLATION_SERIALIZABLE, 

PROPAGATION_MANDATORY, 
PROPAGATION_NESTED, 
PROPAGATION_NEVER, 
PROPAGATION_NOT_SUPPORTED, 
PROPAGATION_REQUIRED, 
PROPAGATION_REQUIRES_NEW, 
PROPAGATION_SUPPORTS, 
TIMEOUT_DEFAULT

final void setIsolationLevel(int isolationLevel) : Set the isolation level.
final void setIsolationLevelName(String constantName)
Set the isolation level by the name of the corresponding constant in TransactionDefinition — for example, "ISOLATION_DEFAULT".
final void setName(String name) Set the name of this transaction.
final void setPropagationBehavior(int propagationBehavior) Set the propagation behavior.
final void setPropagationBehaviorName(String constantName)
Set the propagation behavior by the name of the corresponding constant in TransactionDefinition — for example, "PROPAGATION_REQUIRED".

TransactionTemplate
Template class that simplifies programmatic transaction demarcation and transaction exception handling.
TransactionTemplate(PlatformTransactionManager transactionManager, TransactionDefinition transactionDefinition)
Construct a new TransactionTemplate using the given transaction manager, taking its default settings from the given transaction definition.

<T> T execute(TransactionCallback<T> action)
Execute the action specified by the given callback object within a transaction.

Example-01
=============
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.FileSystemXmlApplicationContext;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionTemplate;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.jdbc.core.JdbcTemplate;

public class TestTransaction {
    public static void main(String[] args) {
        ApplicationContext context = new FileSystemXmlApplicationContext(
                new String[] { "src\\transaction.xml", "src\\MyDataSource.xml", "src\\jdbctemplate.xml" });
        TransactionTemplate transactionTemplate = (TransactionTemplate) context.getBean("transactionTemplate");
        final JdbcTemplate jdbcTemplate = (JdbcTemplate) context.getBean("jdbcTemplate");

        transactionTemplate.execute(new TransactionCallback() {
            public Object doInTransaction(TransactionStatus status) {
                try {
                    jdbcTemplate.update("delete from t_message");
                    jdbcTemplate.update("insert into t_message(id, name) values(1, '____1')");
                    jdbcTemplate.update("insert into t_message(id, name) values(2, '____2')");
                } catch (Exception e) {
                    status.setRollbackOnly();
                }//   w   w w .  d    e m o    2s  .  c    o  m
                return null;
            }
        });
    }
}
https://www.demo2s.com/java/spring-transactiontemplate-execute-transactioncallback-t-action.html
https://www.demo2s.com/java/java-org-springframework-transaction-support-transactiontemplate.html

2.@Transactional
 How to Use @Transactional
We can put the annotation on definitions of interfaces, classes, or directly on methods

Spring applies the class-level annotation to all public methods of this class that we did not annotate with @Transactional.
However, if we put the annotation on a private or protected method, Spring will ignore it without an error.

3. Transaction Propagation
Propagation defines our business logic’s transaction boundary. 
Spring manages to start and pause a transaction according to our propagation setting.

For SUPPORTS, Spring first checks if an active transaction exists. If a transaction exists, 
then the existing transaction will be used. If there isn’t a transaction, it is executed non-transactional:
https://www.baeldung.com/spring-transactional-propagation-isolation

The JTATransactionManager supports real transaction suspension out-of-the-box. 
Others simulate the suspension by holding a reference to the existing one and then clearing it from the thread context.

3.7. NESTED Propagation
For NESTED propagation, Spring checks if a transaction exists, and if so, it marks a save point. 
This means that if our business logic execution throws an exception, then the transaction rollbacks to this save point. 
If there’s no active transaction, it works like REQUIRED.

DataSourceTransactionManager supports this propagation out-of-the-box. 
Some implementations of JTATransactionManager may also support this.

JpaTransactionManager supports NESTED only for JDBC connections. 
However, if we set the nestedTransactionAllowed flag to true, 
it also works for JDBC access code in JPA transactions if our JDBC driver supports save points.

===============================
4. Transaction Isolation
Isolation is one of the common ACID properties: Atomicity, Consistency, Isolation, and Durability. 
Isolation describes how changes applied by concurrent transactions are visible to each other.

Each isolation level prevents zero or more concurrency side effects on a transaction:

Dirty read: read the uncommitted change of a concurrent transaction
Nonrepeatable read: get different value on re-read of a row if a concurrent transaction updates the same row and commits
Phantom read: get different rows after re-execution of a range query if another transaction adds or removes some rows 
in the range and commits
We can set the isolation level of a transaction by @Transactional::isolation. It has these five enumerations in 
Spring: DEFAULT, READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE.

==========================
(1.) How to test controller ?

@WebMvcTest(controllers = {LibraryAssetController.class})
public class LibraryAssetControllerUnitTest {
    private final LibraryAsset bookThingsFallApart =
            LibraryAsset.builder().assetTitle("Things Fall Apart").assetCode("0385474547")
                    .editionYear((short) 1958).creatorName("Chinua Achebe").publisherName("William Heinemann")
                    .priceUSD("17.95").assetCategory(EntityCharacteristics.BOOK_FICTION)
                    .assetType(EntityCharacteristics.BOOK_PAPERBACK).build();

    private final LibraryAsset mediaTAJazz =
            LibraryAsset.builder().assetTitle("Trans Atlantic Jazz").assetCode("0385474548")
                    .editionYear((short) 2001).creatorName("Jazperience").publisherName("L. Asle Roe")
                    .priceUSD("9.95").assetCategory(EntityCharacteristics.MEDIA_AUDIO)
                    .assetType(EntityCharacteristics.MEDIA_AUDIO).build();

    private final List<LibraryAsset> baseAssets = Arrays.asList(this.bookThingsFallApart, this.mediaTAJazz);

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private LibraryAssetService assetService;

    // Tests with the @Test annotation.

}

@Test
    public void whenGetAllAssets_thenControlFlowCorrect() throws Exception {
        Mockito.when(this.assetService.getAllAssets()).thenReturn(this.baseAssets);

        this.mockMvc.perform(MockMvcRequestBuilders.get("/assets/v1/all"))
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andExpect(MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON_VALUE))
                .andExpect(MockMvcResultMatchers.jsonPath("$").isArray())
                .andExpect(
                        MockMvcResultMatchers.jsonPath("$[0].assetCode")
                                .value(this.bookThingsFallApart.getAssetCode())
                ).andExpect(
                        MockMvcResultMatchers.jsonPath("$[1].assetCode")
                                .value(this.mediaTAJazz.getAssetCode())
                );

        Mockito.verify(this.assetService, Mockito.times(1)).getAllAssets();
    }

(2.) 
What Are @WebMvcTest and @SpringBootTest
The @WebMvcTest annotation is used to create MVC (or more specifically controller) related tests. 
It can also be configured to test for a specific controller. It mainly loads and makes testing of the web layer easy.
The @SpringBootTest annotation is used to create a test environment by loading a full application context 
(like classes annotated with @Component and @Service, DB connections, etc). It looks for the main class (which has the @SpringBootApplication annotation) and 
uses it to start the application context.
Both of these annotations were introduced in Spring Boot 1.4.

https://www.baeldung.com/spring-mockmvc-vs-webmvctest
https://www.baeldung.com/junit-datajpatest-repository
